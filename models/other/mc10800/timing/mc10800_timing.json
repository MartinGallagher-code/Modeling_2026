{
  "processor": "Motorola MC10800",
  "manufacturer": "Motorola",
  "year": 1979,
  "schema_version": "1.0",
  "source": "MC10800 datasheet, Motorola ECL bit-slice family documentation",
  "instruction_count": 32,
  "instructions": [
    {"mnemonic": "ADD", "bytes": 1, "cycles": 1, "category": "alu", "addressing_mode": "register", "flags_affected": "C,Z,OV", "notes": "4-bit add R+S"},
    {"mnemonic": "ADDC", "bytes": 1, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "C,Z,OV", "notes": "Add with carry R+S+Cin"},
    {"mnemonic": "SUB", "bytes": 1, "cycles": 1, "category": "alu", "addressing_mode": "register", "flags_affected": "C,Z,OV", "notes": "Subtract R-S"},
    {"mnemonic": "SUBC", "bytes": 1, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "C,Z,OV", "notes": "Subtract with carry R-S-Cin"},
    {"mnemonic": "INC", "bytes": 1, "cycles": 1, "category": "alu", "addressing_mode": "register", "flags_affected": "C,Z,OV", "notes": "Increment R+1"},
    {"mnemonic": "DEC", "bytes": 1, "cycles": 1, "category": "alu", "addressing_mode": "register", "flags_affected": "C,Z,OV", "notes": "Decrement R-1"},
    {"mnemonic": "AND", "bytes": 1, "cycles": 1, "category": "alu", "addressing_mode": "register", "flags_affected": "Z", "notes": "Logical AND R.S"},
    {"mnemonic": "OR", "bytes": 1, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "Z", "notes": "Logical OR R+S"},
    {"mnemonic": "XOR", "bytes": 1, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "Z", "notes": "Logical XOR R^S"},
    {"mnemonic": "NOT", "bytes": 1, "cycles": 1, "category": "alu", "addressing_mode": "register", "flags_affected": "Z", "notes": "Complement ~R"},
    {"mnemonic": "PASS_R", "bytes": 1, "cycles": 1, "category": "alu", "addressing_mode": "register", "flags_affected": "none", "notes": "Pass R source through ALU"},
    {"mnemonic": "PASS_S", "bytes": 1, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "none", "notes": "Pass S source through ALU"},
    {"mnemonic": "SHL", "bytes": 1, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "C,Z", "notes": "Shift left one bit"},
    {"mnemonic": "SHR", "bytes": 1, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "C,Z", "notes": "Shift right one bit"},
    {"mnemonic": "ROL", "bytes": 1, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "C,Z", "notes": "Rotate left through carry"},
    {"mnemonic": "ROR", "bytes": 1, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "C,Z", "notes": "Rotate right through carry"},
    {"mnemonic": "ASR", "bytes": 1, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "C,Z", "notes": "Arithmetic shift right"},
    {"mnemonic": "ZERO", "bytes": 1, "cycles": 1, "category": "alu", "addressing_mode": "register", "flags_affected": "Z", "notes": "Output zero"},
    {"mnemonic": "ONES", "bytes": 1, "cycles": 1, "category": "alu", "addressing_mode": "register", "flags_affected": "none", "notes": "Output all ones"},
    {"mnemonic": "JMP", "bytes": 1, "cycles": 3, "category": "control", "addressing_mode": "microword", "flags_affected": "none", "notes": "Unconditional microsequencer jump"},
    {"mnemonic": "JMPZ", "bytes": 1, "cycles": 3, "category": "control", "addressing_mode": "microword", "flags_affected": "none", "notes": "Jump if zero flag set"},
    {"mnemonic": "JMPC", "bytes": 1, "cycles": 3, "category": "control", "addressing_mode": "microword", "flags_affected": "none", "notes": "Jump if carry flag set"},
    {"mnemonic": "CALL", "bytes": 1, "cycles": 3, "category": "control", "addressing_mode": "microword", "flags_affected": "none", "notes": "Microsequencer call"},
    {"mnemonic": "RET", "bytes": 1, "cycles": 3, "category": "control", "addressing_mode": "implied", "flags_affected": "none", "notes": "Microsequencer return"},
    {"mnemonic": "LOOP", "bytes": 1, "cycles": 3, "category": "control", "addressing_mode": "microword", "flags_affected": "none", "notes": "Microsequencer loop"},
    {"mnemonic": "NOP", "bytes": 1, "cycles": 3, "category": "control", "addressing_mode": "implied", "flags_affected": "none", "notes": "No operation in sequencer"},
    {"mnemonic": "CASCADE_ADD", "bytes": 1, "cycles": 2, "category": "alu", "addressing_mode": "cascade", "flags_affected": "C,Z,OV", "notes": "Cascaded add across slices with carry propagation"},
    {"mnemonic": "CASCADE_SUB", "bytes": 1, "cycles": 3, "category": "alu", "addressing_mode": "cascade", "flags_affected": "C,Z,OV", "notes": "Cascaded subtract across slices"},
    {"mnemonic": "CASCADE_SHL", "bytes": 1, "cycles": 3, "category": "alu", "addressing_mode": "cascade", "flags_affected": "C,Z", "notes": "Cascaded shift left across slices"},
    {"mnemonic": "CASCADE_SHR", "bytes": 1, "cycles": 3, "category": "alu", "addressing_mode": "cascade", "flags_affected": "C,Z", "notes": "Cascaded shift right across slices"},
    {"mnemonic": "CASCADE_CMP", "bytes": 1, "cycles": 2, "category": "alu", "addressing_mode": "cascade", "flags_affected": "C,Z,OV", "notes": "Cascaded compare across slices"},
    {"mnemonic": "CASCADE_AND", "bytes": 1, "cycles": 2, "category": "alu", "addressing_mode": "cascade", "flags_affected": "Z", "notes": "Cascaded AND across slices"}
  ]
}
