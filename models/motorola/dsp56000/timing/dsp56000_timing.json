{
  "processor": "Motorola DSP56000",
  "manufacturer": "Motorola",
  "year": 1986,
  "schema_version": "1.0",
  "source": "DSP56000/DSP56001 Digital Signal Processor User's Manual, Motorola 1990",
  "base_architecture": "dsp56001",
  "base_timing_reference": "models/motorola/dsp56001/timing/dsp56001_timing.json",
  "timing_notes": "Original DSP56000 mask-programmed ROM version of the DSP56001. Same 24-bit Harvard architecture, dual 56-bit accumulators, hardware 24x24 multiplier with single-cycle MAC. 20 MHz clock. DSP56001 added external program RAM; instruction set and timing identical. Three memory buses enable parallel data moves with ALU/MAC operations.",
  "instruction_count": 35,
  "instructions": [
    {"mnemonic": "MAC X0,Y0,A", "opcode": "0x82", "bytes": 2, "cycles": 2, "category": "multiply", "addressing_mode": "register", "flags_affected": "SZLEUV", "notes": "Multiply-accumulate 24x24+56->56, single-cycle MAC"},
    {"mnemonic": "MAC X0,Y0,A X:(R0)+,X0 Y:(R4)+,Y0", "bytes": 2, "cycles": 2, "category": "multiply", "addressing_mode": "register", "flags_affected": "SZLEUV", "notes": "MAC with parallel X and Y data moves"},
    {"mnemonic": "MACR X0,Y0,A", "opcode": "0x83", "bytes": 2, "cycles": 2, "category": "multiply", "addressing_mode": "register", "flags_affected": "SZLEUV", "notes": "Multiply-accumulate and round"},
    {"mnemonic": "MPY X0,Y0,A", "opcode": "0x80", "bytes": 2, "cycles": 2, "category": "multiply", "addressing_mode": "register", "flags_affected": "SZLEUV", "notes": "Signed multiply 24x24->56"},
    {"mnemonic": "MPYR X0,Y0,A", "opcode": "0x81", "bytes": 2, "cycles": 2, "category": "multiply", "addressing_mode": "register", "flags_affected": "SZLEUV", "notes": "Signed multiply and round"},
    {"mnemonic": "ADD X,A", "opcode": "0x40", "bytes": 2, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "SZLEUV", "notes": "Add to accumulator"},
    {"mnemonic": "SUB X,A", "opcode": "0x44", "bytes": 2, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "SZLEUV", "notes": "Subtract from accumulator"},
    {"mnemonic": "ADC X,A", "opcode": "0x41", "bytes": 2, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "SZLEUV", "notes": "Add with carry"},
    {"mnemonic": "SBC X,A", "opcode": "0x45", "bytes": 2, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "SZLEUV", "notes": "Subtract with carry"},
    {"mnemonic": "CMP X0,A", "opcode": "0x46", "bytes": 2, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "SZLEUV", "notes": "Compare"},
    {"mnemonic": "CLR A", "opcode": "0x60", "bytes": 2, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "SZLEUV", "notes": "Clear 56-bit accumulator"},
    {"mnemonic": "NEG A", "opcode": "0x62", "bytes": 2, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "SZLEUV", "notes": "Negate accumulator"},
    {"mnemonic": "ABS A", "opcode": "0x63", "bytes": 2, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "SZLEUV", "notes": "Absolute value"},
    {"mnemonic": "AND X0,A", "opcode": "0x48", "bytes": 2, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "SZL", "notes": "Logical AND"},
    {"mnemonic": "OR X0,A", "opcode": "0x49", "bytes": 2, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "SZL", "notes": "Logical OR"},
    {"mnemonic": "EOR X0,A", "opcode": "0x4A", "bytes": 2, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "SZL", "notes": "Exclusive OR"},
    {"mnemonic": "NOT A", "opcode": "0x4B", "bytes": 2, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "SZL", "notes": "Logical complement"},
    {"mnemonic": "ASL A", "opcode": "0x64", "bytes": 2, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "SZLEUVC", "notes": "Arithmetic shift left"},
    {"mnemonic": "ASR A", "opcode": "0x65", "bytes": 2, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "SZLEUVC", "notes": "Arithmetic shift right"},
    {"mnemonic": "RND A", "opcode": "0x68", "bytes": 2, "cycles": 2, "category": "alu", "addressing_mode": "register", "flags_affected": "SZLEUV", "notes": "Round accumulator (convergent)"},
    {"mnemonic": "DIV X0,A", "opcode": "0x70", "bytes": 2, "cycles": 2, "category": "divide", "addressing_mode": "register", "flags_affected": "SZLEUVC", "notes": "Divide iteration (repeat 24x for full divide)"},
    {"mnemonic": "MOVE X:(R0)+,X0", "bytes": 2, "cycles": 2, "category": "data_transfer", "addressing_mode": "indexed", "flags_affected": "none", "notes": "Move from X memory with post-increment"},
    {"mnemonic": "MOVE Y:(R4)+,Y0", "bytes": 2, "cycles": 2, "category": "data_transfer", "addressing_mode": "indexed", "flags_affected": "none", "notes": "Move from Y memory with post-increment"},
    {"mnemonic": "MOVE #imm,X0", "bytes": 2, "cycles": 2, "category": "data_transfer", "addressing_mode": "immediate", "flags_affected": "none", "notes": "Move immediate to register"},
    {"mnemonic": "TFR X0,A", "bytes": 2, "cycles": 2, "category": "data_transfer", "addressing_mode": "register", "flags_affected": "none", "notes": "Transfer register to accumulator"},
    {"mnemonic": "MOVEP X:<<pp,X0", "bytes": 2, "cycles": 4, "category": "io", "addressing_mode": "direct", "flags_affected": "none", "notes": "Move peripheral data (I/O mapped)"},
    {"mnemonic": "JMP xxxx", "bytes": 2, "cycles": 4, "category": "control", "addressing_mode": "direct", "flags_affected": "none", "notes": "Jump"},
    {"mnemonic": "Bcc xxxx", "bytes": 2, "cycles": 4, "category": "control", "addressing_mode": "relative", "flags_affected": "none", "notes": "Branch conditionally"},
    {"mnemonic": "JSR xxxx", "bytes": 2, "cycles": 4, "category": "control", "addressing_mode": "direct", "flags_affected": "none", "notes": "Jump to subroutine"},
    {"mnemonic": "RTS", "bytes": 2, "cycles": 4, "category": "control", "addressing_mode": "implied", "flags_affected": "none", "notes": "Return from subroutine"},
    {"mnemonic": "RTI", "bytes": 2, "cycles": 4, "category": "control", "addressing_mode": "implied", "flags_affected": "all", "notes": "Return from interrupt"},
    {"mnemonic": "DO #count,label", "bytes": 4, "cycles": 6, "category": "control", "addressing_mode": "immediate", "flags_affected": "none", "notes": "Hardware DO loop (zero-overhead after setup)"},
    {"mnemonic": "REP #count", "bytes": 2, "cycles": 4, "category": "control", "addressing_mode": "immediate", "flags_affected": "none", "notes": "Repeat next instruction N times"},
    {"mnemonic": "NOP", "opcode": "0x00", "bytes": 2, "cycles": 2, "category": "nop", "addressing_mode": "implied", "flags_affected": "none", "notes": "No operation"},
    {"mnemonic": "RESET", "bytes": 2, "cycles": 4, "category": "special", "addressing_mode": "implied", "flags_affected": "none", "notes": "Reset on-chip peripherals"}
  ]
}
