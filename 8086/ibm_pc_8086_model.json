{
  "model_metadata": {
    "name": "IBM PC 8086 CPU Pipeline",
    "version": "1.0",
    "date": "2026-01-22",
    "architecture": "Intel 8086 (IBM PC/XT variant)",
    "description": "Grey-box queueing model for 8086 microprocessor with instruction prefetch queue"
  },
  
  "system_parameters": {
    "clock_freq_mhz": 4.77,
    "clock_freq_hz": 4770000,
    "memory_type": "DRAM (no cache)",
    "address_bus_width": 20,
    "data_bus_width": 16,
    "prefetch_queue_size": 6,
    "notes": "IBM PC uses 8088 variant (8-bit external bus) at 4.77 MHz, but model uses 8086 (16-bit) as baseline"
  },
  
  "pipeline_stages": [
    {
      "stage_id": 1,
      "name": "Bus Interface Unit (BIU) - Prefetch",
      "queue_type": "M/M/1",
      "description": "Fetch instruction bytes into 6-byte prefetch queue",
      "service_time_formula": "cycles_bus_access * (p_queue_empty * penalty_queue_empty + (1 - p_queue_empty) * 1)",
      "parameters": {
        "cycles_bus_access": {
          "value": 4,
          "type": "known",
          "units": "cycles",
          "description": "Bus cycle time for 16-bit memory read (4 T-states)",
          "source": "8086_datasheet",
          "notes": "8088 (8-bit bus) takes 4 cycles, 8086 (16-bit) takes 4 cycles for word"
        },
        "p_queue_empty": {
          "value": 0.15,
          "type": "unknown",
          "bounds": [0.0, 0.5],
          "units": "fraction",
          "description": "Probability prefetch queue is empty (BIU stall)",
          "calibration_source": "execution_profiling",
          "notes": "Depends on instruction mix and execution speed"
        },
        "penalty_queue_empty": {
          "value": 2.0,
          "type": "known",
          "units": "multiplier",
          "description": "Extra delay when queue is empty and EU needs instruction",
          "source": "architectural_analysis"
        }
      },
      "notes": "BIU fetches ahead when bus is idle, fills 6-byte queue"
    },
    
    {
      "stage_id": 2,
      "name": "Execution Unit (EU) - Decode/Execute",
      "queue_type": "M/M/1",
      "description": "Decode instruction from queue and execute",
      "service_time_formula": "p_mov * cycles_mov + p_alu_reg * cycles_alu_reg + p_alu_mem * cycles_alu_mem + p_mul * cycles_mul + p_div * cycles_div + p_shift * cycles_shift + p_string * cycles_string + p_jump_short * cycles_jump_short + p_jump_far * cycles_jump_far + p_call_ret * cycles_call_ret + p_other * cycles_other",
      "parameters": {
        "p_mov": {
          "value": 0.25,
          "type": "unknown",
          "bounds": [0.0, 1.0],
          "units": "fraction",
          "description": "Fraction of MOV instructions (reg-reg, reg-mem, mem-reg)",
          "calibration_source": "instruction_profiling",
          "typical_cycles": "2-17"
        },
        "cycles_mov": {
          "value": 6.0,
          "type": "unknown",
          "bounds": [2.0, 17.0],
          "units": "cycles",
          "description": "Average cycles for MOV instructions",
          "calibration_source": "weighted_by_addressing_modes",
          "notes": "MOV reg,reg=2, MOV mem,reg=9+EA, MOV reg,mem=8+EA"
        },
        "p_alu_reg": {
          "value": 0.20,
          "type": "unknown",
          "bounds": [0.0, 1.0],
          "units": "fraction",
          "description": "Fraction of ALU ops on registers (ADD, SUB, AND, OR, XOR, CMP)",
          "calibration_source": "instruction_profiling",
          "typical_cycles": "3"
        },
        "cycles_alu_reg": {
          "value": 3.0,
          "type": "known",
          "units": "cycles",
          "description": "Cycles for register ALU operations",
          "source": "8086_datasheet"
        },
        "p_alu_mem": {
          "value": 0.15,
          "type": "unknown",
          "bounds": [0.0, 1.0],
          "units": "fraction",
          "description": "Fraction of ALU ops involving memory",
          "calibration_source": "instruction_profiling",
          "typical_cycles": "9-16"
        },
        "cycles_alu_mem": {
          "value": 13.0,
          "type": "unknown",
          "bounds": [9.0, 25.0],
          "units": "cycles",
          "description": "Average cycles for memory ALU operations",
          "calibration_source": "weighted_average",
          "notes": "ADD mem,reg = 16+EA, ADD reg,mem = 9+EA"
        },
        "p_mul": {
          "value": 0.02,
          "type": "unknown",
          "bounds": [0.0, 0.2],
          "units": "fraction",
          "description": "Fraction of multiply instructions",
          "calibration_source": "instruction_profiling",
          "typical_cycles": "70-118"
        },
        "cycles_mul": {
          "value": 90.0,
          "type": "unknown",
          "bounds": [70.0, 130.0],
          "units": "cycles",
          "description": "Average cycles for multiply (byte=70-77, word=118-133)",
          "calibration_source": "weighted_average"
        },
        "p_div": {
          "value": 0.01,
          "type": "unknown",
          "bounds": [0.0, 0.1],
          "units": "fraction",
          "description": "Fraction of divide instructions",
          "calibration_source": "instruction_profiling",
          "typical_cycles": "80-144"
        },
        "cycles_div": {
          "value": 100.0,
          "type": "unknown",
          "bounds": [80.0, 160.0],
          "units": "cycles",
          "description": "Average cycles for divide (byte=80-90, word=144-162)",
          "calibration_source": "weighted_average"
        },
        "p_shift": {
          "value": 0.05,
          "type": "unknown",
          "bounds": [0.0, 0.3],
          "units": "fraction",
          "description": "Fraction of shift/rotate instructions",
          "calibration_source": "instruction_profiling",
          "typical_cycles": "2+4n (n=shift count)"
        },
        "cycles_shift": {
          "value": 8.0,
          "type": "unknown",
          "bounds": [2.0, 35.0],
          "units": "cycles",
          "description": "Average cycles for shift/rotate",
          "calibration_source": "average_shift_count"
        },
        "p_string": {
          "value": 0.03,
          "type": "unknown",
          "bounds": [0.0, 0.2],
          "units": "fraction",
          "description": "Fraction of string operations (MOVS, CMPS, SCAS, LODS, STOS)",
          "calibration_source": "instruction_profiling",
          "typical_cycles": "9-15 per iteration"
        },
        "cycles_string": {
          "value": 12.0,
          "type": "unknown",
          "bounds": [9.0, 15.0],
          "units": "cycles",
          "description": "Average cycles per string operation iteration",
          "calibration_source": "weighted_average"
        },
        "p_jump_short": {
          "value": 0.08,
          "type": "unknown",
          "bounds": [0.0, 0.3],
          "units": "fraction",
          "description": "Fraction of conditional jumps (taken + not taken)",
          "calibration_source": "instruction_profiling",
          "typical_cycles": "4 (not taken) or 16 (taken)"
        },
        "cycles_jump_short": {
          "value": 10.0,
          "type": "unknown",
          "bounds": [4.0, 16.0],
          "units": "cycles",
          "description": "Average cycles for conditional jumps",
          "calibration_source": "branch_prediction_ratio",
          "notes": "Weighted by taken/not-taken ratio"
        },
        "p_jump_far": {
          "value": 0.02,
          "type": "unknown",
          "bounds": [0.0, 0.1],
          "units": "fraction",
          "description": "Fraction of unconditional jumps (JMP, LOOP)",
          "calibration_source": "instruction_profiling",
          "typical_cycles": "15-24"
        },
        "cycles_jump_far": {
          "value": 17.0,
          "type": "unknown",
          "bounds": [15.0, 24.0],
          "units": "cycles",
          "description": "Average cycles for unconditional jumps",
          "calibration_source": "weighted_average"
        },
        "p_call_ret": {
          "value": 0.06,
          "type": "unknown",
          "bounds": [0.0, 0.2],
          "units": "fraction",
          "description": "Fraction of CALL/RET instructions",
          "calibration_source": "instruction_profiling",
          "typical_cycles": "CALL=19-28, RET=8-18"
        },
        "cycles_call_ret": {
          "value": 20.0,
          "type": "unknown",
          "bounds": [8.0, 32.0],
          "units": "cycles",
          "description": "Average cycles for CALL/RET",
          "calibration_source": "weighted_average"
        },
        "p_other": {
          "value": 0.13,
          "type": "derived",
          "formula": "1 - p_mov - p_alu_reg - p_alu_mem - p_mul - p_div - p_shift - p_string - p_jump_short - p_jump_far - p_call_ret",
          "units": "fraction",
          "description": "Stack ops, flags, interrupts, etc.",
          "typical_cycles": "2-15"
        },
        "cycles_other": {
          "value": 6.0,
          "type": "unknown",
          "bounds": [2.0, 20.0],
          "units": "cycles",
          "description": "Average cycles for other operations",
          "calibration_source": "weighted_average"
        }
      },
      "constraints": [
        "p_mov + p_alu_reg + p_alu_mem + p_mul + p_div + p_shift + p_string + p_jump_short + p_jump_far + p_call_ret + p_other = 1.0"
      ],
      "notes": "EU can execute while BIU fetches (pipeline overlap possible)"
    }
  ],
  
  "network_topology": {
    "type": "parallel",
    "description": "BIU and EU operate in parallel - simple 2-stage pipeline",
    "connections": [
      {"from": "external", "to": "BIU", "routing": "deterministic"},
      {"from": "BIU", "to": "6-byte queue", "routing": "deterministic"},
      {"from": "6-byte queue", "to": "EU", "routing": "deterministic"},
      {"from": "EU", "to": "external", "routing": "deterministic"}
    ],
    "pipeline_behavior": "BIU fetches ahead when bus is available, EU consumes from queue"
  },
  
  "calibration_config": {
    "objective": "minimize_cpi_error",
    "tolerance_percent": 5.0,
    "max_iterations": 20,
    "learning_rate": 0.12,
    "priority_order": [
      "p_mov",
      "p_alu_reg",
      "p_alu_mem",
      "p_jump_short",
      "p_call_ret",
      "cycles_mov",
      "cycles_alu_mem",
      "cycles_jump_short",
      "p_queue_empty",
      "p_mul",
      "p_div"
    ],
    "validation_benchmarks": [
      "IBM PC DOS programs",
      "8086 Dhrystone port",
      "Simple loop kernels",
      "Turbo Pascal programs"
    ]
  },
  
  "measurement_requirements": {
    "required_profiling": [
      "instruction distribution (disassemble executable)",
      "addressing mode usage",
      "branch behavior",
      "execution time",
      "queue empty frequency"
    ],
    "recommended_tools": [
      "DOSBox with cycle counting",
      "PCem emulator",
      "8086tiny (cycle-accurate)",
      "Bochs debugger",
      "Turbo Debugger (real hardware)"
    ],
    "ibm_pc_specific": {
      "no_hardware_counters": "8086 has no performance counters",
      "measurement_approach": "Cycle-accurate emulation or logic analyzer on real hardware",
      "typical_programs": "DOS utilities, compilers, games, business software"
    }
  },
  
  "expected_performance": {
    "cpi_range": [2.0, 8.0],
    "typical_cpi": 4.5,
    "instructions_per_second": "1,060,000 IPS at 4.77 MHz (CPI=4.5)",
    "bottleneck_stage": "Execution Unit (EU) - typically",
    "notes": "8086 has simple 2-stage pipeline. CPI varies widely based on instruction mix and addressing modes. Queue empties on jumps/branches."
  },
  
  "architecture_notes": {
    "pipeline_design": "First x86 processor with instruction prefetch queue (6 bytes)",
    "biu_eu_separation": "BIU fetches instructions while EU executes (parallel operation)",
    "queue_behavior": "Queue empties on control transfers (JMP, CALL, RET, conditional jumps taken)",
    "memory_timing": "Memory access takes 4 T-states (bus cycles)",
    "effective_address_calculation": "EA calculation adds cycles: [BX]=5, [BX+SI]=7, [BX+SI+disp]=11",
    "key_differences_from_6502": [
      "Has 2-stage pipeline (6502 is sequential)",
      "16-bit architecture (6502 is 8-bit)",
      "Segment registers (6502 has simple 16-bit addressing)",
      "More complex instruction encoding (1-6 bytes vs 1-3 bytes)",
      "Variable-length instructions",
      "Much wider range of cycle counts (2-162 vs 2-7)"
    ],
    "key_differences_from_modern_x86": [
      "Only 2 pipeline stages (modern has 14-20+)",
      "No out-of-order execution",
      "No branch prediction",
      "No cache",
      "No superscalar execution",
      "16-bit registers and data paths"
    ]
  },
  
  "instruction_cycle_reference": {
    "data_transfer": {
      "MOV_reg_reg": 2,
      "MOV_reg_mem": "8+EA",
      "MOV_mem_reg": "9+EA",
      "PUSH_reg": 11,
      "POP_reg": 8,
      "XCHG_reg_reg": 4
    },
    "arithmetic": {
      "ADD_reg_reg": 3,
      "ADD_reg_mem": "9+EA",
      "ADD_mem_reg": "16+EA",
      "INC_reg": 2,
      "INC_mem": "15+EA",
      "MUL_byte": "70-77",
      "MUL_word": "118-133",
      "DIV_byte": "80-90",
      "DIV_word": "144-162"
    },
    "logical": {
      "AND_reg_reg": 3,
      "OR_reg_reg": 3,
      "XOR_reg_reg": 3,
      "NOT_reg": 3,
      "TEST_reg_reg": 3
    },
    "shift_rotate": {
      "SHL_reg_1": 2,
      "SHL_reg_CL": "8+4*CL",
      "ROL_reg_1": 2,
      "ROL_reg_CL": "8+4*CL"
    },
    "string": {
      "MOVSB": 18,
      "MOVSW": 18,
      "CMPSB": 22,
      "SCASB": 15,
      "LODSB": 12,
      "STOSB": 11,
      "REP_MOVSB": "9+17*CX",
      "REP_STOSB": "9+10*CX"
    },
    "control_transfer": {
      "JMP_short": 15,
      "JMP_near": 15,
      "JMP_far": 15,
      "Jcc_not_taken": 4,
      "Jcc_taken": 16,
      "LOOP_taken": 17,
      "LOOP_not_taken": 5,
      "CALL_near": 19,
      "CALL_far": 28,
      "RET_near": 8,
      "RET_far": 18
    },
    "effective_address": {
      "EA_direct": 0,
      "EA_BX_SI_DI_BP": 5,
      "EA_BX_SI_plus": 7,
      "EA_BP_DI_plus": 8,
      "EA_BX_SI_disp": 11,
      "EA_BP_DI_disp": 12
    }
  },
  
  "queue_behavior": {
    "prefetch_queue_size": 6,
    "bytes_per_fetch": 2,
    "queue_flush_conditions": [
      "Control transfer (JMP, CALL, RET, INT)",
      "Taken conditional jump",
      "Segment register change"
    ],
    "typical_queue_utilization": {
      "sequential_code": "80-90% full",
      "code_with_branches": "40-60% full",
      "branch_heavy_code": "20-40% full"
    },
    "notes": "Queue effectiveness depends heavily on code locality and branch frequency"
  }
}
