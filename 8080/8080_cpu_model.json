{
  "model_metadata": {
    "name": "Intel 8080 CPU Queueing Model",
    "version": "1.0",
    "date": "2026-01-24",
    "author": "Grey-Box Performance Modeling Research",
    "target_cpu": "Intel 8080 (1974-1990)",
    "description": "Baseline sequential CPU model - no prefetch, no cache, simple architecture"
  },
  
  "architecture": {
    "word_size_bits": 8,
    "data_bus_width_bits": 8,
    "address_bus_width_bits": 16,
    "clock_frequency_mhz": 2.0,
    "registers": 7,
    "architecture_type": "accumulator_based",
    "pipeline_stages": 1,
    "notes": "Pure sequential execution, no instruction prefetch or pipelining"
  },
  
  "pipeline_stages": {
    "fetch": {
      "name": "Instruction Fetch",
      "base_cycles": 4,
      "description": "Fetch instruction bytes from memory via 8-bit bus",
      "details": "Average instruction is 1-3 bytes, fetched sequentially"
    },
    "decode_execute": {
      "name": "Decode and Execute",
      "base_cycles": 4,
      "description": "Decode instruction and execute operation",
      "details": "Combined decode/execute stage, no separate pipeline"
    }
  },
  
  "instruction_mix": {
    "description": "Typical 8080 instruction distribution",
    "mov_register": 0.25,
    "alu_operations": 0.35,
    "load_store": 0.20,
    "jump_call": 0.15,
    "io_operations": 0.05,
    "notes": "Based on typical 8080 assembly programs, heavy register usage"
  },
  
  "instruction_timings": {
    "mov_register_register": {
      "cycles": 5,
      "description": "MOV r1, r2 - register to register move"
    },
    "mov_memory": {
      "cycles": 7,
      "description": "MOV r, M or MOV M, r - memory access"
    },
    "alu_register": {
      "cycles": 4,
      "description": "ADD, SUB, AND, OR, XOR with register"
    },
    "alu_memory": {
      "cycles": 7,
      "description": "ADD M, SUB M - ALU with memory operand"
    },
    "alu_immediate": {
      "cycles": 7,
      "description": "ADI, SUI - ALU with immediate"
    },
    "load_store": {
      "lxi": 10,
      "lda": 13,
      "sta": 13,
      "description": "Load/store accumulator or register pair"
    },
    "jump": {
      "jmp": 10,
      "conditional_jump_taken": 10,
      "conditional_jump_not_taken": 7,
      "description": "Unconditional and conditional jumps"
    },
    "call_return": {
      "call": 17,
      "ret": 10,
      "description": "Subroutine call and return"
    },
    "stack": {
      "push": 11,
      "pop": 10,
      "description": "Stack operations"
    },
    "io": {
      "in": 10,
      "out": 10,
      "description": "I/O port access"
    }
  },
  
  "memory_system": {
    "no_cache": true,
    "memory_access_cycles": 3,
    "sequential_access_penalty": 0,
    "bus_width_bytes": 1,
    "description": "Direct memory access, no caching, 8-bit bus requires multiple cycles for multi-byte instructions"
  },
  
  "bottlenecks": {
    "primary": "sequential_execution",
    "secondary": "8-bit_bus_bandwidth",
    "description": "8080 executes one instruction at a time, no parallelism. 8-bit bus limits multi-byte instruction fetch"
  },
  
  "calibration": {
    "arrival_rate_initial": 0.15,
    "arrival_rate_bounds": [0.05, 0.4],
    "tolerance_percent": 2.0,
    "max_iterations": 50,
    "notes": "8080 is slow, expect low IPC due to sequential nature"
  },
  
  "instruction_length_distribution": {
    "1_byte": 0.45,
    "2_byte": 0.35,
    "3_byte": 0.20,
    "average_bytes": 1.75,
    "description": "8080 instruction lengths: 1 byte (simple), 2 byte (immediate), 3 byte (address)"
  },
  
  "execution_characteristics": {
    "purely_sequential": true,
    "no_pipeline": true,
    "no_prefetch": true,
    "no_branch_prediction": true,
    "no_superscalar": true,
    "instruction_level_parallelism": 0,
    "description": "8080 is the simplest baseline - one instruction at a time, start to finish"
  },
  
  "historical_context": {
    "year_introduced": 1974,
    "significance": "First truly usable 8-bit microprocessor, basis for CP/M systems",
    "common_systems": ["Altair 8800", "IMSAI 8080", "Various CP/M machines"],
    "successor": "Intel 8085 (enhanced), Intel 8086 (16-bit evolution)"
  },
  
  "benchmarks": {
    "dhrystone_target_ipc": 0.18,
    "typical_applications": "CP/M operating system, BASIC interpreters, early business applications",
    "performance_notes": "Very low IPC due to sequential execution and multi-cycle instructions"
  }
}
