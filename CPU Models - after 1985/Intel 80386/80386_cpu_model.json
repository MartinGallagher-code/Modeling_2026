{
  "model_name": "Intel 80386 CPU Queueing Model",
  "version": "1.0",
  "date": "2026-01-23",
  "author": "Grey-Box Performance Modeling Research",
  
  "architecture": {
    "cpu_name": "Intel 80386",
    "introduction_year": 1985,
    "data_bus_width": 32,
    "address_bus_width": 32,
    "max_memory": "4 GB",
    "clock_frequency_mhz": 20.0,
    "clock_frequency_range_mhz": [12, 40],
    "prefetch_queue_size": 16,
    "pipeline_type": "in-order with prefetch and cache",
    "registers": "32-bit (EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP)"
  },
  
  "pipeline_stages": {
    "fetch": {
      "description": "Fetch instruction from prefetch queue",
      "base_cycles": 1,
      "model_type": "M/M/1",
      "notes": "Prefetch queue feeds this stage"
    },
    
    "decode": {
      "description": "Decode variable-length 32-bit instructions",
      "base_cycles": 1,
      "model_type": "M/M/1",
      "notes": "More complex than 80286 due to 32-bit instruction set"
    },
    
    "address_calculation": {
      "description": "Segmentation + paging + TLB lookup",
      "base_cycles": 1,
      "model_type": "M/M/1",
      "includes": [
        "segment translation",
        "TLB lookup",
        "page table walk (on TLB miss)"
      ]
    },
    
    "execute": {
      "description": "32-bit ALU, multiply, divide",
      "base_cycles": 1,
      "model_type": "M/M/1",
      "instruction_latencies": {
        "add_sub_32bit": 2,
        "and_or_xor_32bit": 2,
        "shift_32bit": 3,
        "multiply_32bit": 9,
        "divide_32bit": 14,
        "load_effective_address": 2
      },
      "notes": "Significantly faster than 80286 for mul/div"
    },
    
    "memory_access": {
      "description": "Load/store with cache hierarchy",
      "base_cycles": 1,
      "model_type": "M/M/1",
      "includes": [
        "cache lookup",
        "cache hit (fast path)",
        "cache miss (slow path to memory)"
      ]
    },
    
    "writeback": {
      "description": "Write to 32-bit registers and flags",
      "base_cycles": 1,
      "model_type": "M/M/1"
    }
  },
  
  "instruction_mix": {
    "description": "Default instruction mix (workload dependent)",
    "alu": 0.55,
    "multiply": 0.03,
    "divide": 0.01,
    "load": 0.22,
    "store": 0.12,
    "branch": 0.07,
    "notes": "32-bit code has more memory operations than 16-bit"
  },
  
  "cache_system": {
    "enabled": true,
    "description": "On-chip unified cache (some 80386 variants)",
    "size_kb": 8,
    "associativity": "direct-mapped",
    "line_size_bytes": 16,
    "instruction_hit_rate": 0.95,
    "data_hit_rate": 0.88,
    "hit_latency_cycles": 0,
    "miss_latency_cycles": 12,
    "notes": "Not all 80386 had on-chip cache - DX-25 and later typically did"
  },
  
  "memory_system": {
    "has_cache": true,
    "description": "External memory with optional cache",
    "external_memory_access_cycles": 12,
    "external_memory_range_cycles": [8, 20],
    "memory_bus_width": 32,
    "notes": "80386 can access 32-bit memory in one cycle (vs 2 cycles on 80286)"
  },
  
  "paging_system": {
    "enabled": true,
    "description": "80386 introduced x86 paging",
    "page_size_bytes": 4096,
    "tlb_entries": 32,
    "tlb_hit_rate": 0.98,
    "tlb_hit_cycles": 0,
    "tlb_miss_cycles": 1,
    "page_table_walk_cycles": 4,
    "notes": "TLB (Translation Lookaside Buffer) caches virtual-to-physical mappings"
  },
  
  "segmentation": {
    "description": "Segmentation carried over from 80286",
    "segment_translation_cycles": 1,
    "segment_operation_probability": 0.15,
    "notes": "In flat memory model (common on 80386), segmentation is minimal"
  },
  
  "performance": {
    "effective_speedup_vs_80286": 2.5,
    "instructions_per_clock_range": [0.6, 1.0],
    "typical_dhrystone_mips_per_mhz": 1.2,
    "improvements_over_80286": [
      "32-bit data bus (vs 16-bit) → 2x memory bandwidth",
      "Larger prefetch queue (16 vs 6 bytes) → better instruction supply",
      "On-chip cache (optional) → 5-10x memory speedup on hits",
      "Faster multiply/divide → 2-3x faster",
      "Paging support → better virtual memory"
    ],
    "notes": "80386 at 20MHz ≈ 80286 at 50MHz (2.5x speedup)"
  },
  
  "calibration_parameters": {
    "adjustable_parameters": [
      "cache_hit_rate",
      "cache_miss_cycles",
      "tlb_hit_rate",
      "instruction_mix",
      "external_memory_cycles"
    ],
    "fixed_parameters": [
      "prefetch_queue_size",
      "data_bus_width",
      "pipeline_stage_base_cycles"
    ],
    "calibration_workflow": [
      "1. Enable/disable cache based on CPU variant",
      "2. Measure cache hit rates with perf counters",
      "3. Measure TLB hit rates",
      "4. Profile instruction mix",
      "5. Run model.calibrate() to fit memory latency",
      "6. Validate error < 2%"
    ]
  },
  
  "validation_benchmarks": {
    "dhrystone": {
      "description": "Integer arithmetic benchmark",
      "expected_bottleneck": "Execute",
      "typical_ipc": 0.85,
      "cache_sensitivity": "medium"
    },
    
    "whetstone": {
      "description": "Floating point (software emulation on 80386)",
      "expected_bottleneck": "Execute",
      "typical_ipc": 0.40,
      "cache_sensitivity": "low"
    },
    
    "stream": {
      "description": "Memory bandwidth test",
      "expected_bottleneck": "Memory_Access",
      "typical_ipc": 0.65,
      "cache_sensitivity": "high"
    },
    
    "spec_int": {
      "description": "SPEC CPU integer workloads",
      "expected_bottleneck": "varies",
      "typical_ipc": 0.75,
      "cache_sensitivity": "high"
    },
    
    "page_fault_heavy": {
      "description": "Workload with many TLB misses",
      "expected_bottleneck": "Address_Calc",
      "typical_ipc": 0.55,
      "cache_sensitivity": "medium"
    }
  },
  
  "comparison_to_predecessors": {
    "80286": {
      "registers": "80286: 16-bit, 80386: 32-bit",
      "prefetch_queue": "80286: 6 bytes, 80386: 16 bytes",
      "cache": "80286: none, 80386: optional 8-16 KB",
      "paging": "80286: none, 80386: yes (4KB pages)",
      "data_bus": "80286: 16-bit, 80386: 32-bit",
      "performance": "80386 is 2.5-3x faster per MHz"
    },
    
    "8086": {
      "registers": "8086: 16-bit, 80386: 32-bit",
      "addressing": "8086: 1 MB, 80386: 4 GB",
      "protection": "8086: none, 80386: yes (4 rings)",
      "performance": "80386 is 8-10x faster per MHz"
    }
  },
  
  "cpu_variants": {
    "80386DX": {
      "data_bus": 32,
      "typical_cache": "8-16 KB unified",
      "typical_clock": "16-40 MHz",
      "notes": "Full 32-bit external bus"
    },
    
    "80386SX": {
      "data_bus": 16,
      "typical_cache": "none or small",
      "typical_clock": "16-25 MHz",
      "notes": "16-bit external bus (cost-reduced), lower performance"
    }
  },
  
  "modeling_notes": {
    "key_innovations": [
      "Cache hierarchy modeling (hit/miss latency)",
      "TLB modeling (address translation cache)",
      "32-bit instruction set (variable length 1-15 bytes)",
      "Paging overhead (page table walks)",
      "Larger prefetch queue (16 bytes vs 6)"
    ],
    
    "modeling_challenges": [
      "Cache hit rate varies widely by workload",
      "TLB effectiveness depends on working set size",
      "80386SX has 16-bit bus (different memory model)",
      "Some 80386 had no cache (earlier variants)",
      "Variable instruction length complicates prefetch modeling"
    ],
    
    "cache_modeling_approach": [
      "Simple hit/miss model (not full cache simulation)",
      "Hit rate is adjustable parameter (measured from workload)",
      "Miss penalty = external memory latency",
      "Effective latency = hit_rate × hit_latency + miss_rate × miss_latency"
    ],
    
    "future_extensions": [
      "Add 80387 FPU coprocessor model",
      "Model 80386SX 16-bit bus separately",
      "Add L2 cache (for systems with external cache)",
      "Model page fault handling latency",
      "Add interrupt handling"
    ]
  }
}
