{
  "model_metadata": {
    "name": "Zilog Z80 CPU Queueing Model",
    "version": "1.0",
    "date": "2026-01-24",
    "author": "Grey-Box Performance Modeling Research",
    "target_cpu": "Zilog Z80 (1976-present)",
    "description": "Enhanced 8080 with additional registers, indexed addressing, and optimized instruction timing"
  },
  
  "architecture": {
    "word_size_bits": 8,
    "data_bus_width_bits": 8,
    "address_bus_width_bits": 16,
    "clock_frequency_mhz": 4.0,
    "registers_main": 7,
    "registers_alternate": 7,
    "index_registers": 2,
    "architecture_type": "accumulator_with_enhancements",
    "pipeline_stages": 1,
    "notes": "Sequential execution like 8080 but with enhanced instruction set and better timings"
  },
  
  "enhancements_over_8080": {
    "alternate_register_set": "Second set of AF, BC, DE, HL for fast context switching",
    "index_registers": "IX and IY for indexed addressing modes",
    "improved_instruction_timings": "Many instructions execute faster than 8080",
    "additional_instructions": "Bit manipulation, block operations, relative jumps",
    "memory_refresh": "Built-in DRAM refresh (R register)",
    "interrupts": "Enhanced interrupt modes (IM 0, IM 1, IM 2)"
  },
  
  "pipeline_stages": {
    "fetch": {
      "name": "Instruction Fetch",
      "base_cycles": 4,
      "description": "Fetch instruction bytes from memory via 8-bit bus",
      "notes": "Similar to 8080 but with optimizations"
    },
    "decode_execute": {
      "name": "Decode and Execute",
      "base_cycles": 3,
      "description": "Decode instruction and execute operation",
      "notes": "Generally faster than 8080 due to improved microcode"
    }
  },
  
  "instruction_mix": {
    "description": "Typical Z80 instruction distribution (similar to 8080 but with enhancements)",
    "mov_register": 0.28,
    "alu_operations": 0.33,
    "load_store": 0.18,
    "jump_call": 0.13,
    "io_operations": 0.04,
    "bit_operations": 0.04,
    "notes": "Z80 code uses more registers due to alternate set and index registers"
  },
  
  "instruction_timings": {
    "mov_register_register": {
      "cycles": 4,
      "description": "LD r, r' - register to register (faster than 8080's 5 cycles)"
    },
    "mov_memory": {
      "cycles": 7,
      "description": "LD r, (HL) or LD (HL), r"
    },
    "mov_indexed": {
      "cycles": 19,
      "description": "LD r, (IX+d) - indexed addressing (unique to Z80)"
    },
    "alu_register": {
      "cycles": 4,
      "description": "ADD, SUB, AND, OR, XOR with register"
    },
    "alu_memory": {
      "cycles": 7,
      "description": "ADD (HL), SUB (HL) - ALU with memory operand"
    },
    "alu_immediate": {
      "cycles": 7,
      "description": "ADD A, n - ALU with immediate"
    },
    "alu_indexed": {
      "cycles": 19,
      "description": "ADD A, (IX+d) - ALU with indexed addressing"
    },
    "load_store": {
      "ld_nn": 10,
      "ld_addr": 13,
      "st_addr": 13,
      "description": "Load/store accumulator or register pair"
    },
    "jump": {
      "jp": 10,
      "jp_conditional_taken": 10,
      "jp_conditional_not_taken": 10,
      "jr": 12,
      "jr_conditional_taken": 12,
      "jr_conditional_not_taken": 7,
      "description": "Absolute and relative jumps (JR is unique to Z80)"
    },
    "call_return": {
      "call": 17,
      "ret": 10,
      "description": "Subroutine call and return"
    },
    "stack": {
      "push": 11,
      "pop": 10,
      "description": "Stack operations"
    },
    "io": {
      "in": 11,
      "out": 11,
      "description": "I/O port access"
    },
    "bit_operations": {
      "bit": 8,
      "set": 8,
      "res": 8,
      "description": "Bit test, set, reset (unique to Z80)"
    },
    "block_operations": {
      "ldi": 16,
      "ldir": 21,
      "description": "Block copy operations (unique to Z80)"
    },
    "register_exchange": {
      "ex_af": 4,
      "exx": 4,
      "description": "Exchange with alternate register set (very fast)"
    }
  },
  
  "memory_system": {
    "no_cache": true,
    "memory_access_cycles": 3,
    "sequential_access_penalty": 0,
    "bus_width_bytes": 1,
    "memory_refresh": true,
    "refresh_overhead_percent": 2,
    "description": "Direct memory access with automatic DRAM refresh, 8-bit bus"
  },
  
  "bottlenecks": {
    "primary": "sequential_execution",
    "secondary": "8-bit_bus_bandwidth",
    "improvement_over_8080": "Better instruction timings reduce execute stage pressure",
    "description": "Z80 still sequential but executes instructions faster than 8080"
  },
  
  "calibration": {
    "arrival_rate_initial": 0.18,
    "arrival_rate_bounds": [0.08, 0.50],
    "tolerance_percent": 2.0,
    "max_iterations": 50,
    "notes": "Z80 faster than 8080, expect IPC around 0.15-0.20 at moderate load"
  },
  
  "instruction_length_distribution": {
    "1_byte": 0.42,
    "2_byte": 0.38,
    "3_byte": 0.16,
    "4_byte": 0.04,
    "average_bytes": 1.82,
    "description": "Z80 instructions: 1-4 bytes (longer due to prefixes for IX/IY operations)"
  },
  
  "execution_characteristics": {
    "purely_sequential": true,
    "no_pipeline": true,
    "no_prefetch": true,
    "no_branch_prediction": true,
    "no_superscalar": true,
    "instruction_level_parallelism": 0,
    "faster_than_8080": true,
    "description": "Z80 remains sequential like 8080 but with optimized timings"
  },
  
  "historical_context": {
    "year_introduced": 1976,
    "significance": "Popular 8080-compatible processor with enhancements, dominated home computers",
    "common_systems": [
      "Sinclair ZX Spectrum",
      "Amstrad CPC",
      "MSX computers",
      "TRS-80",
      "Sega Master System",
      "Game Boy (modified Z80)"
    ],
    "designer": "Federico Faggin (founder of Zilog, previously at Intel designing 8080)",
    "compatibility": "8080 software compatible, but Z80 code won't run on 8080"
  },
  
  "benchmarks": {
    "dhrystone_target_ipc": 0.18,
    "typical_applications": "CP/M, video games, home computers, embedded systems",
    "performance_vs_8080": "15-30% faster on typical code due to improved timings",
    "notes": "Higher IPC than 8080 due to faster instruction execution"
  },
  
  "performance_comparison": {
    "z80_advantages": [
      "Faster instruction timings (many 4 cycles vs 8080's 5)",
      "Alternate registers reduce memory traffic",
      "Block operations improve bulk data moves",
      "Relative jumps save bytes and cycles"
    ],
    "z80_vs_8080_speedup": "1.15-1.30x on typical code",
    "clock_advantage": "Z80 commonly ran at 4 MHz vs 8080's 2 MHz"
  }
}
